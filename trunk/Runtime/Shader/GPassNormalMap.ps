//--------------------------------------------------------------------------------------
// Constant Buffer Variables
//--------------------------------------------------------------------------------------
Texture2D txNormal : register( t0 );
Texture2D txTransparency : register( t1 );

SamplerState samLinear : register( s0 );
SamplerState samPoint : register( s2 );

cbuffer CB_model : register( b0 )
{
	float m_bumpiness;
	float g_FarClip;
	uint m_bhasOpcityMap;
};

//--------------------------------------------------------------------------------------
// IO structures
//--------------------------------------------------------------------------------------
struct PS_INPUT
{
    float4 Pos : SV_POSITION;
    float2 Tex : TEXCOORD0;
    float3 ViewNormal : TEXCOORD1;
    float3 ViewTangent : TEXCOORD2;
    float3 ViewBinormal : TEXCOORD3;
    float  Depth : TEXCOORD4;	
};

struct PS_OUTPUT
{
	float4 Normals	: SV_Target0;
	float4 Depth	: SV_Target1;
};
//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------
PS_OUTPUT PS( PS_INPUT In)
{
    PS_OUTPUT OUT = (PS_OUTPUT)1;	
	
	// Alpha Test
	if( m_bhasOpcityMap )
	{	
		float alphaTest = txTransparency.Sample( samPoint, In.Tex ).r;
		if( alphaTest < 0.01)
			discard;	
	}
	
    float3 Nn = normalize( In.ViewNormal );
    float3 Tn = normalize( In.ViewTangent );
    float3 Bn = normalize( In.ViewBinormal );
    float3 bump = m_bumpiness * ( txNormal.Sample( samLinear, In.Tex).rgb - float3(0.5,0.5,0.5) );
    
	Nn = Nn + bump.x*Tn + bump.y*Bn;
    Nn = normalize(Nn);
	
	// We store a linear depth term, to be reconstructed using the Frustum Ray method.
	OUT.Depth.x = In.Depth/g_FarClip;
	
	// Normals need to be adjusted from [-1, 1] to [0, 1]
	OUT.Normals.rgb = 0.5f * (Nn + 1.0f);
		
    return OUT;
}
